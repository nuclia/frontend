import { Injectable } from '@angular/core';
import { getParagraphs, ParagraphWithTextAndClassifications } from '../../edit-resource.helpers';
import { EditResourceService } from '../../edit-resource.service';
import { Classification, FieldId, Paragraph, Resource, UserClassification } from '@nuclia/core';
import { ParagraphService } from '../../paragraph.service';
import { Observable } from 'rxjs';

type ParagraphClassificationMap = { [paragraphId: string]: UserClassification[] };

@Injectable({
  providedIn: 'root',
})
export class ParagraphClassificationService extends ParagraphService {
  private _paragraphClassificationMap: ParagraphClassificationMap = {};

  paragraphs: Observable<ParagraphWithTextAndClassifications[]> = this.paragraphList as Observable<
    ParagraphWithTextAndClassifications[]
  >;

  constructor(private editResource: EditResourceService) {
    super();
  }

  initParagraphs(fieldId: FieldId, resource: Resource) {
    const paragraphs: ParagraphWithTextAndClassifications[] = this.getEnhancedParagraphs(fieldId, resource);
    this.setupParagraphs(paragraphs);
  }

  private getEnhancedParagraphs(fieldId: FieldId, resource: Resource): ParagraphWithTextAndClassifications[] {
    this._paragraphClassificationMap = this.getParagraphClassificationMap(resource, fieldId);
    const paragraphs: Paragraph[] = getParagraphs(fieldId, resource);
    return paragraphs.map((paragraph) => {
      const paragraphId = this.editResource.getParagraphId(fieldId, paragraph);
      const userClassifications = this._paragraphClassificationMap[paragraphId] || [];
      const enhancedParagraph: ParagraphWithTextAndClassifications = {
        ...paragraph,
        text: resource.getParagraphText(fieldId.field_type, fieldId.field_id, paragraph),
        paragraphId,
        userClassifications,
        generatedClassifications: this.getGeneratedClassification(paragraph, userClassifications),
      };
      return enhancedParagraph;
    });
  }

  private getParagraphClassificationMap(resource: Resource, fieldId: FieldId): ParagraphClassificationMap {
    return (resource.fieldmetadata || []).reduce((annotationMap, userFieldMetadata) => {
      if (
        userFieldMetadata.field.field === fieldId.field_id &&
        userFieldMetadata.field.field_type === fieldId.field_type
      ) {
        annotationMap = {
          ...annotationMap,
          ...(userFieldMetadata.paragraphs || []).reduce((paragraphAnnotations, annotation) => {
            paragraphAnnotations[annotation.key] = annotation.classifications;
            return paragraphAnnotations;
          }, {} as ParagraphClassificationMap),
        };
      }
      return annotationMap;
    }, {} as ParagraphClassificationMap);
  }

  /**
   * Returns labels generated by the backend which weren't cancelled by the user
   */
  private getGeneratedClassification(
    paragraph: Paragraph,
    userClassifications: UserClassification[],
  ): Classification[] {
    return (paragraph.classifications || []).filter(
      (classification) =>
        !userClassifications.find(
          (userClassification) =>
            userClassification.cancelled_by_user &&
            userClassification.labelset === classification.labelset &&
            userClassification.label === classification.label,
        ),
    );
  }
}
