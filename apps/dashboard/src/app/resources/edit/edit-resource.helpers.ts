import {
  Classification,
  FIELD_TYPE,
  FieldId,
  Paragraph,
  ParagraphAnnotation,
  Resource,
  ResourceData,
  UserClassification,
  UserFieldMetadata,
} from '@nuclia/core';

export type EditResourceView = 'profile' | 'classification' | 'annotation' | 'add-field';

export interface ParagraphWithText extends Paragraph {
  paragraphId: string;
  text?: string;
}

export interface ParagraphWithTextAndClassifications extends ParagraphWithText {
  // labels added to the paragraph by the user, as well as cancellation of backend labels
  userClassifications: UserClassification[];
  // labels generated by the backend which weren't cancelled by the user
  generatedClassifications: Classification[];
}

export interface EntityGroup {
  id: string;
  title: string;
  color: string;
  custom?: boolean;
  entities: string[];
}

/**
 * Currently in our models, there are more FIELD_TYPEs than ResourceData keys, so we need the switch for typing reason
 */
export const getDataKeyFromFieldType = (fieldType: FIELD_TYPE): keyof ResourceData | null => {
  switch (fieldType) {
    case FIELD_TYPE.text:
    case FIELD_TYPE.file:
    case FIELD_TYPE.link:
    case FIELD_TYPE.keywordset:
      return `${fieldType}s`;
    default:
      return null;
  }
};

export const getParagraphs = (fieldId: FieldId, resource: Resource): Paragraph[] => {
  const dataKey = getDataKeyFromFieldType(fieldId.field_type);
  if (!dataKey || !resource.data[dataKey]) {
    return [];
  }
  return resource.data[dataKey]?.[fieldId.field_id]?.extracted?.metadata?.metadata?.paragraphs || [];
};

export const getUpdatedUserFieldMetadata: (
  field: FieldId,
  annotatedParagraphs: ParagraphWithTextAndClassifications[],
  existingEntries: UserFieldMetadata[],
) => UserFieldMetadata[] = (
  field: FieldId,
  annotatedParagraphs: ParagraphWithTextAndClassifications[],
  existingEntries: UserFieldMetadata[],
) => {
  const paragraphAnnotations: ParagraphAnnotation[] = annotatedParagraphs.map((p) => ({
    key: p.paragraphId,
    classifications: p.userClassifications,
  }));

  let existingField = false;
  const newEntries = existingEntries.map((entry) => {
    if (entry.field.field === field.field_id && entry.field.field_type === field.field_type) {
      existingField = true;
      return {
        ...entry,
        paragraphs: paragraphAnnotations,
      };
    } else {
      return entry;
    }
  });

  if (!existingField) {
    newEntries.push({
      field: { field: field.field_id, field_type: field.field_type },
      paragraphs: paragraphAnnotations,
    });
  }
  return newEntries;
};

export const generatedEntitiesColor: { [key: string]: string } = {
  DATE: '#ff8989',
  EVENT: '#cba2da',
  FAC: '#81d8ac',
  GPE: '#454ade',
  LANGUAGE: '#d1d3ff',
  LAW: '#1E264F',
  LOC: '#b7a38d',
  MAIL: '#e81c66',
  MONEY: '#ff8c4b',
  NORP: '#743ccf',
  ORG: '#6eb0ec',
  PERCENT: '#1e264f',
  PERSON: '#ffe186',
  PRODUCT: '#d74f57',
  QUANTITY: '#b035c9',
  TIME: '#21b8a6',
  WORK_OF_ART: '#ffbccc',
};

export const addEntitiesToGroups = (allGroups: EntityGroup[], entitiesMap: { [key: string]: string[] }) => {
  Object.entries(entitiesMap).forEach(([groupId, entities]) => {
    const group = allGroups.find((g) => g.id === groupId);
    if (group) {
      group.entities = group.entities.concat(entities);
    }
  });
};
